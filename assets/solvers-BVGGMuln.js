import{g as z}from"./game-data-dkqy868O.js";const Z=["p_water","p_filtered_water","p_distilled_water","p_steam","p_low_pressure_steam","p_high_pressure_steam"],be=e=>Z.includes(e),D=18,ee=18,te=100,k={m_geothermal_well:{id:"m_geothermal_well",name:"Geothermal Well",type:"additive",tempIncrease:80,maxTemp:220,canChain:!0,maxChains:3},m_firebox:{id:"m_firebox",name:"Firebox",type:"fixed",outputTemp:240},m_industrial_firebox:{id:"m_industrial_firebox",name:"Industrial Firebox",type:"fixed",outputTemp:300},m_electric_water_heater:{id:"m_electric_water_heater",name:"Electric Water Heater",type:"configurable",tempOptions:[{temp:120,power:3e5},{temp:220,power:8e5},{temp:320,power:15e5}]},m_gas_burner:{id:"m_gas_burner",name:"Gas Burner",type:"product_dependent",temps:{p_water:400,p_filtered_water:405,p_distilled_water:410}},m_liquid_boiler:{id:"m_liquid_boiler",name:"Liquid Boiler",type:"product_dependent",temps:{p_water:105}},m_boiler:{id:"m_boiler",name:"Boiler",type:"boiler",defaultHeatLoss:0,steamOutputProduct:"p_steam",minSteamTemp:100},m_coal_generator:{id:"m_coal_generator",name:"Coal Generator",type:"fixed",outputTemp:150,outputProduct:"p_steam"},m_coal_power_plant:{id:"m_coal_power_plant",name:"Coal Power Plant",type:"fixed",outputTemp:500,outputProduct:"p_high_pressure_steam"},m_nuclear_power_plant:{id:"m_nuclear_power_plant",name:"Nuclear Power Plant",type:"fixed",outputTemp:1500,outputProduct:"p_high_pressure_steam"},m_modular_turbine:{id:"m_modular_turbine",name:"Modular Turbine",type:"passthrough",inputProduct:"p_high_pressure_steam",outputProduct:"p_low_pressure_steam"}},Ee=(e,n={},o=D,t=null,a=null)=>{const l=k[e];if(!l)return o;switch(l.type){case"fixed":return l.outputTemp;case"additive":return Math.min(o+l.tempIncrease,l.maxTemp);case"configurable":return n.temperature||l.tempOptions[0].temp;case"product_dependent":return l.temps[t]||l.temps.p_water||400;case"passthrough":return o;case"boiler":const u=a??ee,m=n.heatLoss??l.defaultHeatLoss;return u-m;default:return o}},Ne=(e,n)=>{const o=k[e];if(!o||o.type!=="configurable")return null;const t=o.tempOptions.find(a=>a.temp===n);return t?t.power:null},Ce=e=>e==null?"":`${Math.round(e)}Â°C`,Oe=e=>{const n=k[e];return n&&n.type==="configurable"},Fe=e=>{const n=k[e];return n&&n.type==="boiler"},$e=e=>{const n=k[e];return n?n.type==="configurable"?{temperature:n.tempOptions[0].temp}:n.type==="boiler"?{heatLoss:n.defaultHeatLoss}:{}:{}},ne=e=>e<=0?1/0:e>=400?2:800/e,oe=e=>e<=0?40:e<=300?1500/e+5:e<350?10-(e-300)/25:8,se=e=>e<=18?88:e<=300?3e3/e+10:e<350?20-.2*(e-300):10,re=e=>{if(e<=0)return 30;const n=2973/11,o=4e3/11;return e<=n?30+-165/1982*e:e<o?-99/2054*e+21081/1027:3},ce=e=>e<=0?1/0:64/(.176*Math.abs(e)),j={m_industrial_drill:{type:"steam_input",formula:ne},m_alloyer:{type:"steam_input",formula:oe},m_coal_liquefaction_plant:{type:"steam_input",formula:se},m_steam_cracking_plant:{type:"steam_input",formula:re},m_water_treatment_plant:{type:"steam_input",formula:ce}},v=e=>e in j,W=(e,n,o)=>{const t=j[e];if(!t)return o;const a=t.formula(n);return isFinite(a)?a:o},ae=e=>!e||!e.inputs?!1:e.inputs.some(n=>["p_steam","p_low_pressure_steam","p_high_pressure_steam"].includes(n.product_id)),V=(e,n)=>{const o=new Map,t=new Map;Object.keys(e.nodes).forEach(m=>{const p=e.nodes[m];p&&(p.inputs.forEach((d,i)=>{t.set(`${m}:${i}`,D)}),p.outputs.forEach((d,i)=>{o.set(`${m}:${i}`,D)}))});const{sorted:a,cycleNodes:l}=ie(e),u=(m,p=!1)=>{const d=e.nodes[m];if(!d)return!1;const i={id:d.recipe.machine_id},r=k[i.id];let c=!1;return d.inputs.forEach((f,s)=>{const g=ue(e,n,m,s,o,!p),h=t.get(`${m}:${s}`),_=g!==null?g:h;Math.abs(_-h)>.01&&(t.set(`${m}:${s}`,_),c=!0)}),d.outputs.forEach((f,s)=>{var h,_;let g=D;if(r){if(r.type==="fixed")g=r.outputTemp;else if(r.type==="additive"){if(d.inputs.length>0){const I=t.get(`${m}:0`)||D;I>r.maxTemp?g=I:g=Math.min(I+r.tempIncrease,r.maxTemp)}}else if(r.type==="configurable")g=((h=d.recipe.temperatureSettings)==null?void 0:h.temperature)||r.tempOptions[0].temp;else if(r.type==="product_dependent"){if(d.inputs.length>0){const I=d.inputs[0].productId;g=r.temps[I]||r.temps.p_water||400}}else if(r.type==="boiler"){if(d.inputs.length>=2){const I=t.get(`${m}:1`)||D,w=((_=d.recipe.temperatureSettings)==null?void 0:_.heatLoss)||r.defaultHeatLoss,y=I-w;s===0?g=y*.85:s===1&&(y<r.minSteamTemp?g=Math.max(y,D):g=y)}}else if(r.type==="passthrough"){const I=d.inputs.findIndex(w=>w.productId===r.inputProduct);I>=0&&(g=t.get(`${m}:${I}`)||D)}}o.set(`${m}:${s}`,g)}),c};if(a.forEach(m=>{l.has(m)||u(m)}),l.size>0){let p=0,d=!0;const i=a.filter(c=>l.has(c));for(;d&&p<100;)d=!1,i.forEach(c=>{u(c,!0)&&(d=!0)}),p++;const r=new Set;a.forEach(c=>{if(l.has(c))return;const f=e.nodes[c];f&&f.inputs.forEach((s,g)=>{const h=e.products[s.productId];if(!h)return;h.connections.filter(I=>I.targetNodeId===c&&I.targetInputIndex===g).forEach(I=>{l.has(I.sourceNodeId)&&r.add(c)})})}),r.forEach(c=>{u(c,!1)})}return{outputTemperatures:o,inputTemperatures:t}},ue=(e,n,o,t,a,l=!0)=>{const u=e.products[e.nodes[o].inputs[t].productId];if(!u)return l?D:null;const m=u.connections.filter(r=>r.targetNodeId===o&&r.targetInputIndex===t);if(m.length===0)return l?D:null;const p=[];if(m.forEach(r=>{var f;const c=a.get(`${r.sourceNodeId}:${r.sourceOutputIndex}`);if(c!=null){const s=((f=n.byConnection[r.id])==null?void 0:f.flowRate)||0;p.push({temp:c,flow:s})}}),p.length===0)return l?D:null;const d=p.reduce((r,c)=>r+c.flow,0);if(d>0){const r=p.reduce((c,f)=>c+f.temp*f.flow,0);return Math.round(r/d*1e10)/1e10}const i=p.reduce((r,c)=>r+c.temp,0);return Math.round(i/p.length*1e10)/1e10},ie=e=>{const n=[],o=new Set,t=new Set,a=new Set,l=(u,m=[])=>{if(o.has(u))return;if(t.has(u)){const i=m.indexOf(u);for(let r=i;r<m.length;r++)a.add(m[r]);a.add(u);return}t.add(u);const p=[...m,u],d=e.nodes[u];d&&d.inputs.forEach((i,r)=>{const c=e.products[i.productId];c&&c.connections.filter(s=>s.targetNodeId===u&&s.targetInputIndex===r).forEach(s=>{o.has(s.sourceNodeId)||l(s.sourceNodeId,p)})}),t.delete(u),o.add(u),n.push(u)};return Object.keys(e.nodes).forEach(u=>{o.has(u)||l(u)}),{sorted:n,cycleNodes:a}},B=(e,n,o)=>e.map(t=>{if(!o.nodes[t.id])return t;const l={id:t.data.recipe.machine_id},u=k[l.id],m=v(l.id),p=t.data.recipe.outputs.map((i,r)=>{const c=n.outputTemperatures.get(`${t.id}:${r}`);if(c!=null){if((u==null?void 0:u.type)==="boiler"&&i.product_id==="p_steam"){const f=u.minSteamTemp||100;return c<f?{...i,temperature:c,quantity:0,originalQuantity:i.originalQuantity||i.quantity}:{...i,temperature:c,quantity:i.originalQuantity||i.quantity,originalQuantity:i.originalQuantity||i.quantity}}return{...i,temperature:c}}return i});let d={...t.data.recipe,outputs:p};if(m){const i=j[l.id];if((i==null?void 0:i.type)==="steam_input"){const r=t.data.recipe.inputs.findIndex(c=>["p_steam","p_low_pressure_steam","p_high_pressure_steam"].includes(c.product_id));if(r>=0){const c=n.inputTemperatures.get(`${t.id}:${r}`);if(c!=null&&(d={...d,tempDependentInputTemp:c},l.id==="m_water_treatment_plant")){const s=90*W(l.id,c,1);d={...d,inputs:d.inputs.map((g,h)=>h===1&&["p_steam","p_low_pressure_steam","p_high_pressure_steam"].includes(g.product_id)?{...g,quantity:s,originalQuantity:90}:g)}}}}}return{...t,data:{...t.data,recipe:d}}}),U=(e,n)=>{var l,u,m,p,d,i;if(!e||e.length===0)return{nodes:{},products:{},connections:[]};const o={nodes:{},products:{},connections:[]},t=e.length;for(let r=0;r<t;r++){const c=e[r],f=c.id,s=(l=c.data)==null?void 0:l.recipe,g=((u=c.data)==null?void 0:u.machineCount)||0,h=(m=c.data)==null?void 0:m.machine;if(!s)return;const _=s.isMineshaftDrill||s.id==="r_mineshaft_drill",I=s.isLogicAssembler||s.id==="r_logic_assembler",w=s.isTreeFarm||s.id==="r_tree_farm",y=h&&h.id==="m_industrial_firebox",b=h&&v(h.id),N=_||I||w||y||b;let M=s.cycle_time;if(M==="Variable"||typeof M!="number"||M<=0){if(!N)return;M=1}const T=h&&v(h.id),C=T?j[h.id]:null;if(T&&(C==null?void 0:C.type)==="steam_input"&&!(h.id==="m_steam_cracking_plant"&&!ae(s))){const x=s.tempDependentInputTemp??te;M=W(h.id,x,M)}const O={id:f,recipe:s,machineCount:g,cycleTime:M,isSpecialRecipe:N,isMineshaftDrill:_,isLogicAssembler:I,isTempDependent:T,machineCountMode:((p=c.data)==null?void 0:p.machineCountMode)||"free",cappedMachineCount:(d=c.data)==null?void 0:d.cappedMachineCount,inputs:[],outputs:[]};(i=s.inputs)==null||i.forEach((x,S)=>{const E=x.product_id;if(E==="p_variableproduct")return;const P=typeof x.quantity=="number"?x.quantity:0;if(x.quantity==="Variable"&&!N)return;const $=_?P*g:P/M*g,A=O.inputs.length;O.inputs.push({productId:E,quantity:P,rate:$,index:A,recipeIndex:S,connectedRate:0,temperature:null}),o.products[E]||(o.products[E]={producers:[],consumers:[],connections:[]}),o.products[E].consumers.push({nodeId:f,inputIndex:A,rate:$})});const F=s.outputs;F==null||F.forEach((x,S)=>{const E=x.product_id;if(E==="p_variableproduct")return;const P=typeof x.quantity=="number"?x.quantity:0;if(x.quantity==="Variable"&&!N)return;const $=_?P*g:P/M*g,A=O.outputs.length;O.outputs.push({productId:E,quantity:P,rate:$,index:A,recipeIndex:S,connectedRate:0,temperature:x.temperature||null}),o.products[E]||(o.products[E]={producers:[],consumers:[],connections:[]}),o.products[E].producers.push({nodeId:f,outputIndex:A,rate:$})}),o.nodes[f]=O}const a=n.length;for(let r=0;r<a;r++){const c=n[r],f=o.nodes[c.source],s=o.nodes[c.target];if(!f||!s)continue;const g=parseInt(c.sourceHandle.split("-")[1]),h=parseInt(c.targetHandle.split("-")[1]),_=f.outputs.find(b=>b.recipeIndex===g),I=s.inputs.find(b=>b.recipeIndex===h);if(!_||!I||_.productId!==I.productId)return;const w=_.productId;_.temperature!==void 0&&_.temperature!==null&&(I.temperature=_.temperature);const y={id:c.id,sourceNodeId:c.source,targetNodeId:c.target,sourceOutputIndex:_.index,targetInputIndex:I.index,productId:w,sourceRate:_.rate,targetRate:I.rate,flowRate:0,temperature:_.temperature||null};o.connections.push(y),o.products[w]&&o.products[w].connections.push(y)}return o};class de{constructor(n=100){this.cache=new Map,this.maxSize=n}get(n){if(!this.cache.has(n))return null;const o=this.cache.get(n);return this.cache.delete(n),this.cache.set(n,o),o}set(n,o){if(this.cache.has(n))this.cache.delete(n);else if(this.cache.size>=this.maxSize){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(n,o)}clear(){this.cache.clear()}}let K=new de(100);class pe{constructor(n){this.parent=new Int32Array(n),this.rank=new Int32Array(n);for(let o=0;o<n;o++)this.parent[o]=o}find(n){return this.parent[n]!==n&&(this.parent[n]=this.find(this.parent[n])),this.parent[n]}union(n,o){const t=this.find(n),a=this.find(o);t!==a&&(this.rank[t]<this.rank[a]?this.parent[t]=a:this.rank[t]>this.rank[a]?this.parent[a]=t:(this.parent[a]=t,this.rank[t]++))}}const le=(e,n)=>{const o=e.products[n];if(!o)return{components:[],portToComponent:new Map};const t=[],a=new Map;o.producers.forEach(i=>{const r=`out:${i.nodeId}:${i.outputIndex}`;a.has(r)||(a.set(r,t.length),t.push({type:"output",nodeId:i.nodeId,index:i.outputIndex,rate:i.rate}))}),o.consumers.forEach(i=>{const r=`in:${i.nodeId}:${i.inputIndex}`;a.has(r)||(a.set(r,t.length),t.push({type:"input",nodeId:i.nodeId,index:i.inputIndex,rate:i.rate}))});const l=new pe(t.length);o.connections.forEach(i=>{const r=`out:${i.sourceNodeId}:${i.sourceOutputIndex}`,c=`in:${i.targetNodeId}:${i.targetInputIndex}`,f=a.get(r),s=a.get(c);f!==void 0&&s!==void 0&&l.union(f,s)});const u=new Map;for(let i=0;i<t.length;i++){const r=l.find(i);u.has(r)||u.set(r,[]),u.get(r).push(i)}const m=[],p=new Map;let d=0;return u.forEach((i,r)=>{const c={id:d,ports:i.map(f=>t[f]),connections:[]};o.connections.forEach(f=>{const s=`out:${f.sourceNodeId}:${f.sourceOutputIndex}`,g=a.get(s);g!==void 0&&l.find(g)===r&&c.connections.push(f)}),i.forEach(f=>{const s=t[f],g=s.type==="output"?`out:${s.nodeId}:${s.index}`:`in:${s.nodeId}:${s.index}`;p.set(g,d)}),m.push(c),d++}),{components:m,portToComponent:p,ports:t,portToIndex:a}},fe=e=>{const n=e.ports.map(t=>`${t.type}:${t.nodeId}:${t.index}:${t.rate}`).sort().join("|"),o=e.connections.map(t=>`${t.sourceNodeId}:${t.sourceOutputIndex}->${t.targetNodeId}:${t.targetInputIndex}`).sort().join("|");return`${n}##${o}`},he=(e,n,o)=>{const t=X(e,n),a=J(e,n),l={totalProduction:t,totalConsumption:a,connectedFlow:0,connections:{}};if(o.length===0)return l;const{components:u,portToComponent:m}=le(e,n);return u.forEach(p=>{if(p.connections.length===0)return;const d=fe(p),i=`${n}:comp${p.id}`,r=K.get(i);let c;if(r&&r.hash===d)c=JSON.parse(JSON.stringify(r.result));else{const f=ge(p.connections,t),s=_e(f);c={connectedFlow:0,connections:{}},p.connections.forEach((h,_)=>{const I=s.connectionFlows[_]||0;c.connections[h.id]={flowRate:I,supplyRatio:h.sourceRate>0?I/h.sourceRate:0,demandRatio:h.targetRate>0?I/h.targetRate:0},c.connectedFlow+=I});const g=Object.freeze({connectedFlow:c.connectedFlow,connections:Object.freeze({...c.connections})});K.set(i,{hash:d,result:g})}Object.assign(l.connections,c.connections),l.connectedFlow+=c.connectedFlow}),l},me=e=>Math.abs(e)<1e-9?0:Math.round(e*1e8)/1e8,ge=(e,n)=>{const o=new Map;let t=0;const a=f=>{let s=o.get(f);return s===void 0&&(s=t++,o.set(f,s)),s},l=a("virtual-source"),u=a("virtual-sink"),m=new Map,p=new Map;e.forEach(f=>{const s=`out:${f.sourceNodeId}:${f.sourceOutputIndex}`,g=`in:${f.targetNodeId}:${f.targetInputIndex}`;a(s),a(g),m.has(s)||m.set(s,f.sourceRate),p.has(g)||p.set(g,f.targetRate)});const d=Array.from({length:t},()=>[]),i=[],r=n||1e6,c=(f,s,g,h=-1)=>{const _=i.length,I=i.length+1;i.push({to:s,cap:g,flow:0,rev:I,connIndex:h}),i.push({to:f,cap:0,flow:0,rev:_,connIndex:-1}),d[f].push(_),d[s].push(I)};return m.forEach((f,s)=>{c(l,a(s),f)}),p.forEach((f,s)=>{c(a(s),u,f)}),e.forEach((f,s)=>{const g=`out:${f.sourceNodeId}:${f.sourceOutputIndex}`,h=`in:${f.targetNodeId}:${f.targetInputIndex}`,_=a(g),I=a(h);c(_,I,r,s)}),{adj:d,edges:i,nodeCount:t,SOURCE:l,SINK:u}};class Ie{constructor(n){this.buffer=new Array(n),this.head=0,this.tail=0,this.size=0,this.capacity=n}push(n){this.buffer[this.tail]=n,this.tail=(this.tail+1)%this.capacity,this.size++}shift(){const n=this.buffer[this.head];return this.head=(this.head+1)%this.capacity,this.size--,n}isEmpty(){return this.size===0}clear(){this.head=0,this.tail=0,this.size=0}}const _e=e=>{const{adj:n,edges:o,nodeCount:t,SOURCE:a,SINK:l}=e,u=new Int32Array(t),m=new Int32Array(t),p=new Ie(t),d=()=>{for(u.fill(-1),u[a]=0,p.clear(),p.push(a);!p.isEmpty();){const h=p.shift(),_=n[h],I=_.length;for(let w=0;w<I;w++){const y=o[_[w]],b=y.cap-y.flow;u[y.to]<0&&b>1e-15&&(u[y.to]=u[h]+1,p.push(y.to))}}return u[l]>=0},i=()=>{const h=[a],_=new Int32Array(t).fill(-1),I=new Uint8Array(t);for(I[a]=1;h.length>0;){const w=h[h.length-1];if(w===l){let N=1e15,M=l;for(;M!==a;){const T=_[M],C=o[T],O=C.cap-C.flow;N=Math.min(N,O);let F=!1;for(let x=0;x<t;x++){const S=n[x];for(let E=0;E<S.length;E++)if(S[E]===T){M=x,F=!0;break}if(F)break}}for(M=l;M!==a;){const T=_[M];o[T].flow+=N,o[o[T].rev].flow-=N;let C=!1;for(let O=0;O<t;O++){const F=n[O];for(let x=0;x<F.length;x++)if(F[x]===T){M=O,C=!0;break}if(C)break}}return N}let y=!1;const b=n[w];for(let N=m[w];N<b.length;N++){const M=b[N],T=o[M],C=T.cap-T.flow;if(u[w]+1===u[T.to]&&C>1e-15&&!I[T.to]){I[T.to]=1,_[T.to]=M,h.push(T.to),m[w]=N,y=!0;break}}y||(h.pop(),m[w]=b.length)}return 0};let r=0,c=0;const f=1e5;for(;d()&&c++<f;)for(m.fill(0);;){const h=i();if(h===0)break;r+=h}const s=[],g=o.length;for(let h=0;h<g;h++){const _=o[h];_.connIndex>=0&&(s[_.connIndex]=me(_.flow))}return{totalFlow:r,connectionFlows:s}},H=e=>{const n={byProduct:{},byConnection:{},byNode:{}};return Object.keys(e.nodes).forEach(o=>{const t=e.nodes[o];n.byNode[o]={inputFlows:t.inputs.map(a=>({connected:0,needed:a.rate})),outputFlows:t.outputs.map(a=>({connected:0,produced:a.rate}))}}),Object.keys(e.products).forEach(o=>{const a=e.products[o].connections;if(a.length===0){n.byProduct[o]={totalProduction:X(e,o),totalConsumption:J(e,o),connectedFlow:0};return}const l=he(e,o,a);n.byProduct[o]=l,a.forEach(u=>{const m=l.connections[u.id];if(m){n.byConnection[u.id]=m;const p=n.byNode[u.sourceNodeId];p&&(p.outputFlows[u.sourceOutputIndex].connected+=m.flowRate,p.outputFlows[u.sourceOutputIndex].produced=u.sourceRate);const d=n.byNode[u.targetNodeId];d&&(d.inputFlows[u.targetInputIndex].connected+=m.flowRate,d.inputFlows[u.targetInputIndex].needed=u.targetRate)}})}),n},X=(e,n)=>{const o=e.products[n];return o?o.producers.reduce((t,a)=>{const u=e.nodes[a.nodeId].outputs[a.outputIndex];return t+u.rate},0):0},J=(e,n)=>{const o=e.products[n];return o?o.consumers.reduce((t,a)=>{const u=e.nodes[a.nodeId].inputs[a.inputIndex];return t+u.rate},0):0},Pe=()=>{K.clear()},ye=.001,we=1e-6,G=(e,n)=>{const o=Math.max(Math.abs(e),Math.abs(n))*ye,t=Math.max(o,we);return Math.abs(e)>t},L=1e-6,Te=(e,n,o,t)=>{var i,r;const a=new Map,l=new Set,u=(i=e.nodes[o])==null?void 0:i.inputs[t];if(!u)return a;const m=u.productId;if(!e.products[m])return a;const d=[{nodeId:o,inputIndex:t,productId:m}];for(l.add(`${o}:${t}`);d.length>0;){const{nodeId:c,inputIndex:f,productId:s}=d.shift();(((r=e.products[s])==null?void 0:r.connections.filter(h=>h.targetNodeId===c&&h.targetInputIndex===f))||[]).forEach(h=>{var y,b;const _=e.nodes[h.sourceNodeId];if(!_)return;const I=`${h.sourceNodeId}:${h.sourceOutputIndex}`,w=(y=n.byNode[h.sourceNodeId])==null?void 0:y.outputFlows[h.sourceOutputIndex];if(w){a.set(I,{nodeId:h.sourceNodeId,outputIndex:h.sourceOutputIndex,maxFlow:w.produced});const N=_.outputs[h.sourceOutputIndex];if(!N)return;(((b=e.products[N.productId])==null?void 0:b.connections.filter(T=>T.sourceNodeId===h.sourceNodeId&&T.sourceOutputIndex===h.sourceOutputIndex))||[]).forEach(T=>{var F;if(T.targetNodeId===c&&T.targetInputIndex===f)return;const C=`${T.targetNodeId}:${T.targetInputIndex}`;if(l.has(C))return;l.add(C);const O=(F=e.nodes[T.targetNodeId])==null?void 0:F.inputs[T.targetInputIndex];O&&d.push({nodeId:T.targetNodeId,inputIndex:T.targetInputIndex,productId:O.productId})})}})}return a},xe=(e,n)=>{const o=[];return Object.keys(e.nodes).forEach(t=>{const a=e.nodes[t],l=n.byNode[t];l&&a.inputs.forEach((u,m)=>{const p=l.inputFlows[m];if(!p)return;const d=p.needed-p.connected;if(!G(d,p.needed)||d<=0)return;if(u.productId,Te(e,n,t,m).forEach((c,f)=>{var C;const s=e.nodes[c.nodeId];if(!s)return;const g=s.machineCount||0;if(g<=0)return;const h=s.machineCountMode||"free";if(h==="locked")return;let _=s.cycleTime;(typeof _!="number"||_<=0)&&(_=1);const I=s.outputs[c.outputIndex];if(!I)return;const w=I.originalQuantity!==void 0?I.originalQuantity:I.quantity;if(typeof w!="number")return;const y=s.isMineshaftDrill?w:w/_;if(typeof y!="number"||y<=L)return;const b=(C=n.byNode[c.nodeId])==null?void 0:C.outputFlows[c.outputIndex];if(!b)return;const N=d/y;let M=g+N;if(h==="capped"&&s.cappedMachineCount&&(M=Math.min(M,s.cappedMachineCount),M<=g+L))return;const T=s.outputs.length>1&&s.outputs.some((O,F)=>{if(F===c.outputIndex)return!1;const x=e.products[O.productId];return!x||!x.connections.some(E=>E.sourceNodeId===c.nodeId&&E.sourceOutputIndex===F)?!1:x.connections.some(E=>E.sourceNodeId!==c.nodeId||E.sourceOutputIndex!==F?!1:x.connections.filter($=>$.targetNodeId===E.targetNodeId&&$.targetInputIndex===E.targetInputIndex&&$.sourceNodeId!==c.nodeId).length===0)});o.push({nodeId:c.nodeId,handleType:"output",handleIndex:c.outputIndex,productId:I.productId,adjustmentType:"increase",reason:"connected_shortage",currentFlow:b.produced,targetFlow:b.produced+d,deltaFlow:d,currentMachineCount:g,suggestedMachineCount:M,machineDelta:N,hasConstrainedOutputs:T,isMultiOutput:s.outputs.length>1})}),(a.machineCountMode||"free")!=="locked"){const c=a.isMineshaftDrill?u.quantity:u.quantity/(a.cycleTime||1);if(typeof c=="number"&&c>L){const f=d/c,s=(a.machineCount||0)-f;s>L&&o.push({nodeId:t,handleType:"input",handleIndex:m,productId:u.productId,adjustmentType:"decrease",reason:"shortage",currentFlow:p.connected,targetFlow:p.connected,deltaFlow:-d,currentMachineCount:a.machineCount||0,suggestedMachineCount:s,machineDelta:-f})}}})}),Object.keys(e.nodes).forEach(t=>{const a=e.nodes[t],l=n.byNode[t];if(!l)return;const u=a.machineCount||0;if(u<=0)return;let m=a.cycleTime;(typeof m!="number"||m<=0)&&(m=1),a.outputs.forEach((p,d)=>{var w;const i=l.outputFlows[d];if(!i)return;const r=i.produced-i.connected;if(!G(r,i.produced)||r<=0||(a.machineCountMode||"free")==="locked")return;const f=p.originalQuantity!==void 0?p.originalQuantity:p.quantity,s=a.isMineshaftDrill?f:f/m;if(typeof s!="number"||s<=L)return;const g=r/s,h=u-g;h>L&&o.push({nodeId:t,handleType:"output",handleIndex:d,productId:p.productId,adjustmentType:"decrease",reason:"excess",currentFlow:i.produced,targetFlow:i.produced-r,deltaFlow:-r,currentMachineCount:u,suggestedMachineCount:h,machineDelta:-g});const _=p.productId;(((w=e.products[_])==null?void 0:w.connections.filter(y=>y.sourceNodeId===t&&y.sourceOutputIndex===d))||[]).forEach(y=>{var S,E,P,$;const b=e.nodes[y.targetNodeId];if(!b)return;const N=b.machineCount||0;if(N<=0)return;const M=b.machineCountMode||"free";if(M==="locked")return;let T=b.cycleTime;(typeof T!="number"||T<=0)&&(T=1);const C=b.inputs[y.targetInputIndex];if(!C)return;const O=b.isMineshaftDrill?C.quantity:C.quantity/T;if(typeof O!="number"||O<=L)return;const F=r/O;let x=N+F;M==="capped"&&b.cappedMachineCount&&(x=Math.min(x,b.cappedMachineCount),x<=N+L)||o.push({nodeId:y.targetNodeId,handleType:"input",handleIndex:y.targetInputIndex,productId:C.productId,adjustmentType:"increase",reason:"excess_available",currentFlow:((E=(S=n.byNode[y.targetNodeId])==null?void 0:S.inputFlows[y.targetInputIndex])==null?void 0:E.connected)||0,targetFlow:((($=(P=n.byNode[y.targetNodeId])==null?void 0:P.inputFlows[y.targetInputIndex])==null?void 0:$.connected)||0)+r,deltaFlow:r,currentMachineCount:N,suggestedMachineCount:x,machineDelta:F})})})}),o.forEach(t=>{const a=Math.round(t.suggestedMachineCount*1e10)/1e10,l=Math.round(t.suggestedMachineCount*1e20)/1e20,u=Math.abs(l-a)>1e-12;t.suggestedMachineCount=u?Math.round(t.suggestedMachineCount*1e20)/1e20:Math.round(t.suggestedMachineCount*1e10)/1e10;const m=Math.round(t.machineDelta*1e10)/1e10,p=Math.round(t.machineDelta*1e20)/1e20,d=Math.abs(p-m)>1e-12;t.machineDelta=d?Math.round(t.machineDelta*1e20)/1e20:Math.round(t.machineDelta*1e10)/1e10}),o},q=(e,n)=>{const o=[],t=[],u=(p,d)=>{const i=Math.max(Math.abs(p),Math.abs(d))*1e-4,r=Math.max(i,1e-6);return Math.abs(p)>r};Object.keys(e.products).forEach(p=>{const d=e.products[p],i=n.byProduct[p];if(!i)return;const r=i.totalProduction,c=i.connectedFlow,f=r-c;if(u(f,r)&&f>0){const s=z(p);s&&o.push({productId:p,product:s,excessRate:f,totalProduction:r,connectedConsumption:c,percentageExcess:r>0?f/r*100:0})}d.consumers.forEach(s=>{var h;const g=(h=n.byNode[s.nodeId])==null?void 0:h.inputFlows[s.inputIndex];if(g){const _=g.needed-g.connected;if(u(_,g.needed)&&_>0){const I=z(p);if(I){let w=t.find(y=>y.productId===p);w?(w.deficiencyRate+=_,w.affectedNodes.push({nodeId:s.nodeId,inputIndex:s.inputIndex,shortage:_})):t.push({productId:p,product:I,deficiencyRate:_,totalConsumption:i.totalConsumption,connectedProduction:c,percentageDeficient:i.totalConsumption>0?_/i.totalConsumption*100:0,affectedNodes:[{nodeId:s.nodeId,inputIndex:s.inputIndex,shortage:_}]})}}}})}),o.sort((p,d)=>d.excessRate-p.excessRate),t.sort((p,d)=>d.deficiencyRate-p.deficiencyRate);const m=o.length>0||t.length>0?xe(e,n):[];return{excess:o,deficiency:t,suggestions:m}},Se=(e,n,o={})=>{const{skipTemperature:t=!1,previousTemperatureData:a=null}=o,l=U(e,n),u=H(l);if(t){const I=a||{outputTemperatures:new Map,inputTemperatures:new Map,geothermalChains:new Map};return{...q(l,u),graph:l,flows:u,temperatureData:I}}if(!Object.values(l.nodes).some(I=>{const w=I.recipe.machine_id;return k[w]||v(w)})){const I={outputTemperatures:new Map,inputTemperatures:new Map,geothermalChains:new Map};return{...q(l,u),graph:l,flows:u,temperatureData:I}}const p=V(l,u),d=B(e,p,l);if(!d.some((I,w)=>{var F,x,S,E,P,$,A,Q;const y=e[w],b=(x=(F=y.data)==null?void 0:F.recipe)==null?void 0:x.tempDependentInputTemp,N=(E=(S=I.data)==null?void 0:S.recipe)==null?void 0:E.tempDependentInputTemp,M=($=(P=y.data)==null?void 0:P.recipe)==null?void 0:$.outputs.map(R=>R.temperature).filter(R=>R!==void 0),T=(Q=(A=I.data)==null?void 0:A.recipe)==null?void 0:Q.outputs.map(R=>R.temperature).filter(R=>R!==void 0),C=Math.abs((b||0)-(N||0))>.1,O=M.length!==T.length||M.some((R,Y)=>Math.abs((R||0)-(T[Y]||0))>.1);return C||O}))return{...q(l,u),graph:l,flows:u,temperatureData:p};const r=U(d,n),c=H(r),f=V(r,c),s=B(d,f,r),g=U(s,n),h=H(g);return{...q(g,h),graph:g,flows:h,temperatureData:f}},De=e=>e.excess||[],Re=e=>e.deficiency||[];export{te as D,k as H,j as T,Fe as a,W as b,Ee as c,$e as d,ee as e,Ce as f,Ne as g,v as h,be as i,D as j,Pe as k,De as l,Re as m,Oe as n,B as o,U as p,ae as r,Se as s};
